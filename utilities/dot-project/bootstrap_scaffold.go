package projects

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"text/template"
	"time"
)

// projectYAMLTemplate is the template for generating project.yaml.
// It produces valid YAML with TODO comments for fields that need manual input.
const projectYAMLTemplate = `# .project metadata for {{ .Name }}
# Generated by bootstrap tool — review and fill in TODO items
# Documentation: https://github.com/cncf/automation/tree/main/utilities/dot-project
{{ range .TODOs }}
# TODO: {{ . }}{{ end }}

schema_version: "1.0.0"
slug: "{{ .Slug }}"
name: "{{ .Name }}"
description: "{{ .Description }}"{{ if .ProjectLead }}
project_lead: "{{ .ProjectLead }}"{{ else }}
# TODO: Set project lead GitHub handle
# project_lead: "github-handle"{{ end }}{{ if .CNCFSlackChannel }}
cncf_slack_channel: "{{ .CNCFSlackChannel }}"{{ else }}
# TODO: Set CNCF Slack channel
# cncf_slack_channel: "#{{ .Slug }}"{{ end }}

maturity_log:
  - phase: "{{ or .MaturityPhase "sandbox" }}"
    date: "{{ formatTime .AcceptedDate }}"
    issue: "https://github.com/cncf/toc/issues/XXX" # TODO: Set TOC issue URL

repositories:{{ if .Repositories }}{{ range .Repositories }}
  - "{{ . }}"{{ end }}{{ else }}
  # TODO: Add repository URLs
  - "https://github.com/org/repo"{{ end }}
{{ if .Website }}
website: "{{ .Website }}"{{ else }}
# TODO: Add project website
# website: "https://{{ .Slug }}.io"{{ end }}
{{ if .Artwork }}
artwork: "{{ .Artwork }}"{{ end }}
{{ if .HasAdopters }}
adopters:
  path: "ADOPTERS.md"{{ else }}
# TODO: Add ADOPTERS.md if your project tracks adopters
# adopters:
#   path: "ADOPTERS.md"{{ end }}

# TODO: Add package manager identifiers if your project is distributed via registries
# package_managers:
#   docker: "org/image"
#   npm: "package-name"
{{ if .Social }}
social:{{ range $platform, $url := .Social }}
  {{ $platform }}: "{{ $url }}"{{ end }}{{ end }}

security:
  policy:
    path: "SECURITY.md"{{ if .SecurityContactURL }}
  contact: "{{ .SecurityContactURL }}"{{ else }}
  # TODO: Set security contact email
  # contact: "security@{{ .Slug }}.io"{{ end }}
{{ if .HasContributing }}
governance:
  contributing:
    path: "CONTRIBUTING.md"{{ end }}
{{ if .HasLicense }}
legal:
  license:
    path: "LICENSE"{{ end }}
  # TODO: Set contributor identity agreements
  # identity_type:
  #   has_dco: true   # DCO can be used alone
  #   has_cla: false  # CLA requires DCO
{{ if .HasReadme }}
documentation:
  readme:
    path: "README.md"{{ end }}
{{ if and .LandscapeCategory .LandscapeSubcategory }}
landscape:
  category: "{{ .LandscapeCategory }}"
  subcategory: "{{ .LandscapeSubcategory }}"{{ end }}
{{ if .CLOMonitorScore }}
# CLOMonitor Score: {{ printf "%.0f" .CLOMonitorScore.Global }}/100
# Documentation: {{ printf "%.0f" .CLOMonitorScore.Documentation }} | License: {{ printf "%.0f" .CLOMonitorScore.License }} | Best Practices: {{ printf "%.0f" .CLOMonitorScore.BestPractices }} | Security: {{ printf "%.0f" .CLOMonitorScore.Security }}{{ end }}
`

// maintainersYAMLTemplate is the template for generating maintainers.yaml.
const maintainersYAMLTemplate = `# Maintainer roster for {{ .Name }}
# Generated by bootstrap tool — review and verify all handles
# Documentation: https://github.com/cncf/automation/tree/main/utilities/dot-project
{{ if not .Maintainers }}
# TODO: Add maintainer GitHub handles{{ end }}

maintainers:
  - project_id: "{{ .Slug }}"
    # TODO: Set GitHub organization
    # org: "my-org"
    teams:
      - name: "project-maintainers"
        members:{{ if .Maintainers }}{{ range .Maintainers }}
          - {{ . }}{{ end }}{{ else }}
          # TODO: Add maintainer handles
          - github-handle{{ end }}{{ if .Reviewers }}
      - name: "reviewers"
        members:{{ range .Reviewers }}
          - {{ . }}{{ end }}{{ end }}
`

// templateFuncs provides helper functions for templates.
var templateFuncs = template.FuncMap{
	"formatTime": func(t time.Time) string {
		if t.IsZero() {
			return time.Now().Format("2006-01-02T15:04:05Z")
		}
		return t.Format("2006-01-02T15:04:05Z")
	},
	"or": func(a, b string) string {
		if a != "" {
			return a
		}
		return b
	},
}

// GenerateProjectYAML produces the project.yaml content from a BootstrapResult.
func GenerateProjectYAML(result *BootstrapResult) ([]byte, error) {
	tmpl, err := template.New("project").Funcs(templateFuncs).Parse(projectYAMLTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing project template: %w", err)
	}

	// Build a view with safe defaults
	view := struct {
		*BootstrapResult
		Name string // override to ensure non-empty
	}{
		BootstrapResult: result,
		Name:            result.Name,
	}
	if view.Name == "" {
		view.Name = result.Slug
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, view); err != nil {
		return nil, fmt.Errorf("executing project template: %w", err)
	}

	// Clean up excessive blank lines (more than 2 consecutive)
	output := cleanBlankLines(buf.String())

	return []byte(output), nil
}

// GenerateMaintainersYAML produces the maintainers.yaml content from a BootstrapResult.
func GenerateMaintainersYAML(result *BootstrapResult) ([]byte, error) {
	tmpl, err := template.New("maintainers").Parse(maintainersYAMLTemplate)
	if err != nil {
		return nil, fmt.Errorf("parsing maintainers template: %w", err)
	}

	// Build view
	view := struct {
		*BootstrapResult
		Name string
	}{
		BootstrapResult: result,
		Name:            result.Name,
	}
	if view.Name == "" {
		view.Name = result.Slug
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, view); err != nil {
		return nil, fmt.Errorf("executing maintainers template: %w", err)
	}

	output := cleanBlankLines(buf.String())

	return []byte(output), nil
}

// WriteScaffold writes project.yaml, maintainers.yaml, and the CI workflow
// to the specified directory. It will not overwrite existing files.
func WriteScaffold(dir string, result *BootstrapResult) error {
	// Check for existing files first
	files := []string{"project.yaml", "maintainers.yaml"}
	for _, f := range files {
		path := filepath.Join(dir, f)
		if _, err := os.Stat(path); err == nil {
			return fmt.Errorf("%s already exists in %s; refusing to overwrite", f, dir)
		}
	}

	// Generate project.yaml
	projectYAML, err := GenerateProjectYAML(result)
	if err != nil {
		return fmt.Errorf("generating project.yaml: %w", err)
	}

	// Generate maintainers.yaml
	maintainersYAML, err := GenerateMaintainersYAML(result)
	if err != nil {
		return fmt.Errorf("generating maintainers.yaml: %w", err)
	}

	// Write project.yaml
	if err := os.WriteFile(filepath.Join(dir, "project.yaml"), projectYAML, 0644); err != nil {
		return fmt.Errorf("writing project.yaml: %w", err)
	}

	// Write maintainers.yaml
	if err := os.WriteFile(filepath.Join(dir, "maintainers.yaml"), maintainersYAML, 0644); err != nil {
		return fmt.Errorf("writing maintainers.yaml: %w", err)
	}

	// Copy workflow template
	workflowDir := filepath.Join(dir, ".github", "workflows")
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return fmt.Errorf("creating workflow directory: %w", err)
	}

	workflowContent := `name: Validate Project Metadata

on:
  pull_request:
    paths:
      - 'project.yaml'
      - 'maintainers.yaml'
  push:
    branches: [main]
    paths:
      - 'project.yaml'
      - 'maintainers.yaml'

jobs:
  validate-project:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd

      - uses: cncf/automation/.github/actions/validate-project@main
        with:
          project_file: 'project.yaml'

  validate-maintainers:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd
        with:
          fetch-depth: 0

      - uses: cncf/automation/.github/actions/validate-maintainers@main
        with:
          maintainers_file: 'maintainers.yaml'
          verify_maintainers: 'true'
        env:
          LFX_AUTH_TOKEN: ${{ secrets.LFX_AUTH_TOKEN }}
`

	if err := os.WriteFile(filepath.Join(workflowDir, "validate.yaml"), []byte(workflowContent), 0644); err != nil {
		return fmt.Errorf("writing workflow: %w", err)
	}

	return nil
}

// cleanBlankLines reduces runs of 3+ consecutive blank lines to at most 2.
func cleanBlankLines(s string) string {
	lines := strings.Split(s, "\n")
	var result []string
	blankCount := 0
	for _, line := range lines {
		if strings.TrimSpace(line) == "" {
			blankCount++
			if blankCount <= 2 {
				result = append(result, line)
			}
		} else {
			blankCount = 0
			result = append(result, line)
		}
	}
	return strings.Join(result, "\n")
}
