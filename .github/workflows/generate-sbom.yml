name: Generate SBOM for CNCF Projects

on:
  schedule:
    # Run weekly on Sunday at 02:00 UTC
    - cron: '0 2 * * 0'
  workflow_dispatch:
    inputs:
      project_filter:
        description: 'Filter by owner/repo (e.g., "kubernetes/kubernetes"), leave empty for all'
        required: false
        default: ''
      force_regenerate:
        description: 'Force regenerate existing SBOMs'
        required: false
        default: false
        type: boolean
      releases_mode:
        description: 'Which releases to process'
        required: false
        default: 'recent'
        type: choice
        options:
          - recent    # Only releases from the past week
          - latest    # Latest N releases regardless of date
      max_releases:
        description: 'Maximum number of releases to process per repo (only used with "latest" mode)'
        required: false
        default: '3'
        type: choice
        options:
          - '1'
          - '2'
          - '3'
          - '4'
          - '5'
      source:
        description: 'Which repositories to process'
        required: false
        default: 'all'
        type: choice
        options:
          - all           # Both CNCF projects and discovered repos
          - cncf          # Only official CNCF projects
          - discovered    # Only discovered repos from CNCF orgs

permissions:
  contents: write

jobs:
  # ===========================================
  # Prepare matrix for official CNCF projects
  # ===========================================
  prepare-cncf-matrix:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.source != 'discovered' }}
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_repos: ${{ steps.set-matrix.outputs.has_repos }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Generate CNCF projects matrix
        id: set-matrix
        run: |
          FILTER="${{ github.event.inputs.project_filter }}"
          PROJECTS_FILE="supply-chain/util/data/cncf-projects.yaml"
          
          if [ ! -f "$PROJECTS_FILE" ]; then
            echo "Error: $PROJECTS_FILE not found. Run the sync-cncf-projects workflow first."
            exit 1
          fi
          
          if [ -n "$FILTER" ]; then
            OWNER=$(echo "$FILTER" | cut -d'/' -f1)
            REPO=$(echo "$FILTER" | cut -d'/' -f2)
            MATRIX=$(yq -o=json '.repositories | map(select(.owner == "'"$OWNER"'" and .repo == "'"$REPO"'")) | {"include": .}' "$PROJECTS_FILE" | jq -c .)
          else
            MATRIX=$(yq -o=json '{"include": .repositories}' "$PROJECTS_FILE" | jq -c .)
          fi
          
          REPO_COUNT=$(echo "$MATRIX" | jq '.include | length')
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "has_repos=$( [ "$REPO_COUNT" -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT
          echo "Generated CNCF matrix with $REPO_COUNT repositories"

  # ===========================================
  # Prepare matrix for discovered repos
  # ===========================================
  prepare-discovered-matrix:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.source != 'cncf' }}
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_repos: ${{ steps.set-matrix.outputs.has_repos }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Generate discovered repos matrix
        id: set-matrix
        run: |
          FILTER="${{ github.event.inputs.project_filter }}"
          DISCOVERED_FILE="supply-chain/util/data/discovered-repos.yaml"
          
          if [ ! -f "$DISCOVERED_FILE" ]; then
            echo "No discovered-repos.yaml found, skipping discovered repos"
            echo 'matrix={"include":[]}' >> $GITHUB_OUTPUT
            echo "has_repos=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [ -n "$FILTER" ]; then
            OWNER=$(echo "$FILTER" | cut -d'/' -f1)
            REPO=$(echo "$FILTER" | cut -d'/' -f2)
            MATRIX=$(yq -o=json '.repositories | map(select(.owner == "'"$OWNER"'" and .repo == "'"$REPO"'")) | {"include": .}' "$DISCOVERED_FILE" | jq -c .)
          else
            MATRIX=$(yq -o=json '{"include": .repositories}' "$DISCOVERED_FILE" | jq -c .)
          fi
          
          REPO_COUNT=$(echo "$MATRIX" | jq '.include | length')
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "has_repos=$( [ "$REPO_COUNT" -gt 0 ] && echo 'true' || echo 'false' )" >> $GITHUB_OUTPUT
          echo "Generated discovered repos matrix with $REPO_COUNT repositories"

  # ===========================================
  # Generate SBOMs for official CNCF projects
  # ===========================================
  generate-sbom-cncf:
    needs: prepare-cncf-matrix
    if: ${{ needs.prepare-cncf-matrix.outputs.has_repos == 'true' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix: ${{ fromJson(needs.prepare-cncf-matrix.outputs.matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          cache: false

      - name: Install bom tool and go-licenses
        run: |
          go install sigs.k8s.io/bom/cmd/bom@latest
          go install github.com/google/go-licenses@latest
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Check if repository is a Go project
        id: check-go
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          OWNER="${{ matrix.owner }}"
          REPO="${{ matrix.repo }}"
          
          echo "Checking if $OWNER/$REPO is a Go project..."
          
          HAS_GO_MOD=$(gh api repos/${OWNER}/${REPO}/contents/go.mod --jq '.name' 2>/dev/null || echo "")
          HAS_GO_SUM=$(gh api repos/${OWNER}/${REPO}/contents/go.sum --jq '.name' 2>/dev/null || echo "")
          
          if [ -n "$HAS_GO_MOD" ] || [ -n "$HAS_GO_SUM" ]; then
            echo "Found Go project files"
            echo "is_go_project=true" >> $GITHUB_OUTPUT
          else
            echo "No go.mod or go.sum found - skipping"
            echo "is_go_project=false" >> $GITHUB_OUTPUT
          fi

      - name: Get stable releases and generate SBOMs
        id: generate
        if: steps.check-go.outputs.is_go_project == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FORCE_REGENERATE: ${{ github.event.inputs.force_regenerate }}
          RELEASES_MODE: ${{ github.event.inputs.releases_mode || 'recent' }}
          MAX_RELEASES: ${{ github.event.inputs.max_releases || '3' }}
        run: |
          set -e
          
          OWNER="${{ matrix.owner }}"
          REPO="${{ matrix.repo }}"
          PROJECT_NAME="${{ matrix.name }}"
          SANITIZED_PROJECT=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-')
          SBOM_BASE_DIR="supply-chain/sbom/${SANITIZED_PROJECT}/${REPO}"
          GENERATED_FILES=""
          PROCESSED=0
          
          ONE_WEEK_AGO=$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-7d +%Y-%m-%dT%H:%M:%SZ)
          
          echo "::group::Processing $PROJECT_NAME ($OWNER/$REPO)"
          echo "Releases mode: $RELEASES_MODE"
          
          extract_go_licenses() {
            local DIR="$1"
            local OUTPUT_FILE="$2"
            
            if [ ! -f "$DIR/go.mod" ]; then
              echo "[]" > "$OUTPUT_FILE"
              return 0
            fi
            
            echo "  Extracting Go licenses..."
            cd "$DIR"
            go mod download 2>/dev/null || true
            
            local LICENSES_CSV
            LICENSES_CSV=$(go-licenses csv ./... 2>/dev/null || echo "")
            
            if [ -z "$LICENSES_CSV" ]; then
              echo "[]" > "$OUTPUT_FILE"
              cd - > /dev/null
              return 0
            fi
            
            echo "$LICENSES_CSV" | awk -F',' '{
              gsub(/"/, "\\\"", $1);
              gsub(/"/, "\\\"", $2);
              gsub(/"/, "\\\"", $3);
              id = $1;
              gsub(/[^a-zA-Z0-9]/, "-", id);
              id = substr(id, 1, 50);
              printf "{\"licenseId\": \"LicenseRef-%s\", \"extractedText\": \"License: %s\", \"name\": \"%s\", \"comment\": \"Package: %s, License URL: %s\"}\n", id, $3, $3, $1, $2
            }' | jq -s '.' > "$OUTPUT_FILE" 2>/dev/null || echo "[]" > "$OUTPUT_FILE"
            
            cd - > /dev/null
            return 0
          }
          
          generate_sbom() {
            local TAG="$1"
            local VERSION=$(echo "$TAG" | sed 's/^v//')
            local SBOM_DIR="${SBOM_BASE_DIR}/${VERSION}"
            local SBOM_FILE="${SBOM_DIR}/${REPO}.json"
            
            if [ -f "$SBOM_FILE" ] && [ "$FORCE_REGENERATE" != "true" ]; then
              echo "SBOM already exists: $SBOM_FILE, skipping..."
              return 1
            fi
            
            echo "Generating SBOM for $OWNER/$REPO@$TAG..."
            
            local TEMP_DIR=$(mktemp -d)
            if ! git clone --depth 1 --branch "$TAG" "https://github.com/${OWNER}/${REPO}.git" "$TEMP_DIR" 2>/dev/null; then
              echo "Failed to clone $OWNER/$REPO@$TAG, skipping..."
              rm -rf "$TEMP_DIR"
              return 1
            fi
            
            mkdir -p "$SBOM_DIR"
            
            local SBOM_NAME="${PROJECT_NAME} - ${REPO} ${TAG}"
            local SBOM_NAMESPACE="https://github.com/${OWNER}/${REPO}/releases/tag/${TAG}"
            
            if bom generate --format json --name "$SBOM_NAME" --namespace "$SBOM_NAMESPACE" --output "$SBOM_FILE" "$TEMP_DIR" 2>/dev/null; then
              local LICENSES_FILE=$(mktemp)
              extract_go_licenses "$TEMP_DIR" "$LICENSES_FILE"
              
              local TEMP_SBOM=$(mktemp)
              jq --arg owner "$OWNER" \
                 --arg repo "$REPO" \
                 --arg tag "$TAG" \
                 --arg project "$PROJECT_NAME" \
                 --arg ghUrl "https://github.com/${OWNER}/${REPO}" \
                 --arg releaseUrl "https://github.com/${OWNER}/${REPO}/releases/tag/${TAG}" \
                 --arg generatedAt "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                 --slurpfile licenses "$LICENSES_FILE" \
                 '
                 .creationInfo.creators += ["Tool: cncf-automation-sbom-generator", "Tool: go-licenses"] |
                 .creationInfo.comment = "SBOM generated for CNCF project: \($project) (\($owner)/\($repo)@\($tag))" |
                 .annotations = ((.annotations // []) + [{
                   "annotationDate": $generatedAt,
                   "annotationType": "OTHER",
                   "annotator": "Tool: cncf-automation",
                   "comment": "CNCF Project: \($project)\nRepository: \($owner)/\($repo)\nVersion: \($tag)"
                 }]) |
                 .hasExtractedLicensingInfo = ((.hasExtractedLicensingInfo // []) + $licenses[0])
                 ' "$SBOM_FILE" > "$TEMP_SBOM" && mv "$TEMP_SBOM" "$SBOM_FILE"
              
              rm -f "$LICENSES_FILE"
              echo "Successfully generated SBOM: $SBOM_FILE"
              GENERATED_FILES="$GENERATED_FILES $SBOM_FILE"
              rm -rf "$TEMP_DIR"
              return 0
            else
              echo "Failed to generate SBOM for $OWNER/$REPO@$TAG"
              rm -rf "$TEMP_DIR"
              return 1
            fi
          }
          
          RELEASES=$(gh api repos/${OWNER}/${REPO}/releases --paginate -q '.[0:50]' 2>/dev/null || echo "[]")
          
          if [ "$RELEASES" == "[]" ] || [ -z "$RELEASES" ]; then
            echo "No releases found, trying tags..."
            TAGS=$(gh api repos/${OWNER}/${REPO}/tags --paginate -q '.[0:20] | .[].name' 2>/dev/null || echo "")
            
            if [ -z "$TAGS" ]; then
              echo "No tags found, skipping..."
              echo "::endgroup::"
              exit 0
            fi
            
            EFFECTIVE_MAX=$( [ "$RELEASES_MODE" == "recent" ] && echo 3 || echo $MAX_RELEASES )
            
            for TAG in $TAGS; do
              if echo "$TAG" | grep -qiE '[-\.](alpha|beta|rc|pre|dev|snapshot|nightly|canary|test|draft|wip)[0-9]*'; then
                continue
              fi
              
              if ! echo "$TAG" | grep -qE '^v?[0-9]+\.[0-9]+'; then
                continue
              fi
              
              if generate_sbom "$TAG"; then
                PROCESSED=$((PROCESSED + 1))
              fi
              
              if [ "$PROCESSED" -ge "$EFFECTIVE_MAX" ]; then
                break
              fi
            done
          else
            if [ "$RELEASES_MODE" == "recent" ]; then
              readarray -t RELEASE_DATA < <(echo "$RELEASES" | jq -r --arg since "$ONE_WEEK_AGO" '.[] | select(.draft == false and .prerelease == false and .published_at >= $since) | "\(.tag_name)|\(.published_at)"')
            else
              readarray -t RELEASE_DATA < <(echo "$RELEASES" | jq -r '.[] | select(.draft == false and .prerelease == false) | "\(.tag_name)|\(.published_at)"')
            fi
            
            for RELEASE_INFO in "${RELEASE_DATA[@]}"; do
              TAG=$(echo "$RELEASE_INFO" | cut -d'|' -f1)
              
              if echo "$TAG" | grep -qiE '[-\.](alpha|beta|rc|pre|dev|snapshot|nightly|canary|test|draft|wip)[0-9]*'; then
                continue
              fi
              
              if generate_sbom "$TAG"; then
                PROCESSED=$((PROCESSED + 1))
              fi
              
              if [ "$RELEASES_MODE" == "latest" ] && [ "$PROCESSED" -ge "$MAX_RELEASES" ]; then
                break
              fi
            done
          fi
          
          echo "::endgroup::"

      - name: Commit and push SBOMs
        if: steps.check-go.outputs.is_go_project == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add supply-chain/sbom/
          
          if git diff --cached --quiet; then
            echo "No new SBOMs generated"
            exit 0
          fi
          
          git commit -m "chore(sbom): update SBOM for ${{ matrix.owner }}/${{ matrix.repo }}"
          
          for i in $(seq 1 5); do
            if git pull --rebase origin ${{ github.ref_name }} && git push origin HEAD:${{ github.ref_name }}; then
              exit 0
            fi
            sleep $((i * 5))
          done
          exit 1

  # ===========================================
  # Generate SBOMs for discovered repos
  # ===========================================
  generate-sbom-discovered:
    needs: prepare-discovered-matrix
    if: ${{ needs.prepare-discovered-matrix.outputs.has_repos == 'true' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix: ${{ fromJson(needs.prepare-discovered-matrix.outputs.matrix) }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          cache: false

      - name: Install bom tool and go-licenses
        run: |
          go install sigs.k8s.io/bom/cmd/bom@latest
          go install github.com/google/go-licenses@latest
          echo "$(go env GOPATH)/bin" >> $GITHUB_PATH

      - name: Get stable releases and generate SBOMs
        id: generate
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          FORCE_REGENERATE: ${{ github.event.inputs.force_regenerate }}
          RELEASES_MODE: ${{ github.event.inputs.releases_mode || 'recent' }}
          MAX_RELEASES: ${{ github.event.inputs.max_releases || '3' }}
        run: |
          set -e
          
          OWNER="${{ matrix.owner }}"
          REPO="${{ matrix.repo }}"
          PROJECT_NAME="${{ matrix.name }}"
          SANITIZED_PROJECT=$(echo "$PROJECT_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | tr -cd '[:alnum:]-')
          SBOM_BASE_DIR="supply-chain/sbom/subprojects/${OWNER}/${REPO}"
          PROCESSED=0
          
          ONE_WEEK_AGO=$(date -u -d '7 days ago' +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -v-7d +%Y-%m-%dT%H:%M:%SZ)
          
          echo "::group::Processing discovered repo: $OWNER/$REPO"
          echo "Releases mode: $RELEASES_MODE"
          
          extract_go_licenses() {
            local DIR="$1"
            local OUTPUT_FILE="$2"
            
            if [ ! -f "$DIR/go.mod" ]; then
              echo "[]" > "$OUTPUT_FILE"
              return 0
            fi
            
            cd "$DIR"
            go mod download 2>/dev/null || true
            
            local LICENSES_CSV
            LICENSES_CSV=$(go-licenses csv ./... 2>/dev/null || echo "")
            
            if [ -z "$LICENSES_CSV" ]; then
              echo "[]" > "$OUTPUT_FILE"
              cd - > /dev/null
              return 0
            fi
            
            echo "$LICENSES_CSV" | awk -F',' '{
              gsub(/"/, "\\\"", $1);
              id = $1; gsub(/[^a-zA-Z0-9]/, "-", id); id = substr(id, 1, 50);
              printf "{\"licenseId\": \"LicenseRef-%s\", \"extractedText\": \"License: %s\", \"name\": \"%s\", \"comment\": \"Package: %s\"}\n", id, $3, $3, $1
            }' | jq -s '.' > "$OUTPUT_FILE" 2>/dev/null || echo "[]" > "$OUTPUT_FILE"
            
            cd - > /dev/null
          }
          
          generate_sbom() {
            local TAG="$1"
            local VERSION=$(echo "$TAG" | sed 's/^v//')
            local SBOM_DIR="${SBOM_BASE_DIR}/${VERSION}"
            local SBOM_FILE="${SBOM_DIR}/${REPO}.json"
            
            if [ -f "$SBOM_FILE" ] && [ "$FORCE_REGENERATE" != "true" ]; then
              echo "SBOM already exists, skipping..."
              return 1
            fi
            
            echo "Generating SBOM for $OWNER/$REPO@$TAG..."
            
            local TEMP_DIR=$(mktemp -d)
            if ! git clone --depth 1 --branch "$TAG" "https://github.com/${OWNER}/${REPO}.git" "$TEMP_DIR" 2>/dev/null; then
              rm -rf "$TEMP_DIR"
              return 1
            fi
            
            mkdir -p "$SBOM_DIR"
            
            local SBOM_NAME="${OWNER}/${REPO} ${TAG}"
            local SBOM_NAMESPACE="https://github.com/${OWNER}/${REPO}/releases/tag/${TAG}"
            
            if bom generate --format json --name "$SBOM_NAME" --namespace "$SBOM_NAMESPACE" --output "$SBOM_FILE" "$TEMP_DIR" 2>/dev/null; then
              local LICENSES_FILE=$(mktemp)
              extract_go_licenses "$TEMP_DIR" "$LICENSES_FILE"
              
              local TEMP_SBOM=$(mktemp)
              jq --arg owner "$OWNER" \
                 --arg repo "$REPO" \
                 --arg tag "$TAG" \
                 --arg ghUrl "https://github.com/${OWNER}/${REPO}" \
                 --arg generatedAt "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                 --slurpfile licenses "$LICENSES_FILE" \
                 '
                 .creationInfo.creators += ["Tool: cncf-automation-sbom-generator"] |
                 .creationInfo.comment = "SBOM for CNCF org subproject: \($owner)/\($repo)@\($tag)" |
                 .annotations = ((.annotations // []) + [{
                   "annotationDate": $generatedAt,
                   "annotationType": "OTHER",
                   "annotator": "Tool: cncf-automation",
                   "comment": "CNCF Org Subproject: \($owner)/\($repo)\nVersion: \($tag)"
                 }]) |
                 .hasExtractedLicensingInfo = ((.hasExtractedLicensingInfo // []) + $licenses[0])
                 ' "$SBOM_FILE" > "$TEMP_SBOM" && mv "$TEMP_SBOM" "$SBOM_FILE"
              
              rm -f "$LICENSES_FILE"
              echo "Successfully generated SBOM: $SBOM_FILE"
              rm -rf "$TEMP_DIR"
              return 0
            else
              rm -rf "$TEMP_DIR"
              return 1
            fi
          }
          
          RELEASES=$(gh api repos/${OWNER}/${REPO}/releases --paginate -q '.[0:50]' 2>/dev/null || echo "[]")
          
          if [ "$RELEASES" == "[]" ] || [ -z "$RELEASES" ]; then
            TAGS=$(gh api repos/${OWNER}/${REPO}/tags --paginate -q '.[0:20] | .[].name' 2>/dev/null || echo "")
            
            if [ -z "$TAGS" ]; then
              echo "No tags found, skipping..."
              echo "::endgroup::"
              exit 0
            fi
            
            EFFECTIVE_MAX=$( [ "$RELEASES_MODE" == "recent" ] && echo 3 || echo $MAX_RELEASES )
            
            for TAG in $TAGS; do
              if echo "$TAG" | grep -qiE '[-\.](alpha|beta|rc|pre|dev|snapshot|nightly|canary|test|draft|wip)[0-9]*'; then
                continue
              fi
              if ! echo "$TAG" | grep -qE '^v?[0-9]+\.[0-9]+'; then
                continue
              fi
              if generate_sbom "$TAG"; then
                PROCESSED=$((PROCESSED + 1))
              fi
              if [ "$PROCESSED" -ge "$EFFECTIVE_MAX" ]; then
                break
              fi
            done
          else
            if [ "$RELEASES_MODE" == "recent" ]; then
              readarray -t RELEASE_DATA < <(echo "$RELEASES" | jq -r --arg since "$ONE_WEEK_AGO" '.[] | select(.draft == false and .prerelease == false and .published_at >= $since) | "\(.tag_name)"')
            else
              readarray -t RELEASE_DATA < <(echo "$RELEASES" | jq -r '.[] | select(.draft == false and .prerelease == false) | "\(.tag_name)"')
            fi
            
            for TAG in "${RELEASE_DATA[@]}"; do
              if echo "$TAG" | grep -qiE '[-\.](alpha|beta|rc|pre|dev|snapshot|nightly|canary|test|draft|wip)[0-9]*'; then
                continue
              fi
              if generate_sbom "$TAG"; then
                PROCESSED=$((PROCESSED + 1))
              fi
              if [ "$RELEASES_MODE" == "latest" ] && [ "$PROCESSED" -ge "$MAX_RELEASES" ]; then
                break
              fi
            done
          fi
          
          echo "::endgroup::"

      - name: Commit and push SBOMs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          git add supply-chain/sbom/
          
          if git diff --cached --quiet; then
            echo "No new SBOMs generated"
            exit 0
          fi
          
          git commit -m "chore(sbom): update SBOM for discovered repo ${{ matrix.owner }}/${{ matrix.repo }}"
          
          for i in $(seq 1 5); do
            if git pull --rebase origin ${{ github.ref_name }} && git push origin HEAD:${{ github.ref_name }}; then
              exit 0
            fi
            sleep $((i * 5))
          done
          exit 1

  # ===========================================
  # Aggregate and generate index
  # ===========================================
  aggregate-sboms:
    needs: [generate-sbom-cncf, generate-sbom-discovered]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Pull latest changes
        run: |
          git pull --rebase origin ${{ github.ref_name }} || git pull origin ${{ github.ref_name }}

      - name: Generate SBOM index
        run: |
          cd supply-chain/util/generate-index
          go run . "${{ github.workspace }}"

      - name: Commit index
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          if ! git diff --quiet supply-chain/sbom/index.json 2>/dev/null; then
            git add supply-chain/sbom/index.json
            git commit -m "chore(sbom): update SBOM index" || true
            git push origin ${{ github.ref_name }} || true
          fi
