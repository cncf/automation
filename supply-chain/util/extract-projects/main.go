package main

import (
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

const landscapeURL = "https://raw.githubusercontent.com/cncf/landscape/master/landscape.yml"

type LandscapeItem struct {
	Name    string                 `yaml:"name"`
	Project string                 `yaml:"project"`
	RepoURL string                 `yaml:"repo_url"`
	Extra   map[string]interface{} `yaml:"extra"`
}

type Subcategory struct {
	Name  string          `yaml:"name"`
	Items []LandscapeItem `yaml:"items"`
}

type Category struct {
	Name          string        `yaml:"name"`
	Subcategories []Subcategory `yaml:"subcategories"`
}

type Landscape struct {
	Landscape []Category `yaml:"landscape"`
}

type ProjectEntry struct {
	Owner         string `yaml:"owner"`
	Repo          string `yaml:"repo"`
	Name          string `yaml:"name"`
	Category      string `yaml:"category"`
	ProjectStatus string `yaml:"project_status"`
	AcceptedDate  string `yaml:"accepted_date,omitempty"`
}

type Metadata struct {
	Source        string `yaml:"source"`
	Description   string `yaml:"description"`
	AutoGenerated bool   `yaml:"auto_generated"`
}

type Output struct {
	Metadata     Metadata       `yaml:"metadata"`
	Repositories []ProjectEntry `yaml:"repositories"`
}

var categoryMapping = map[string][]string{
	"orchestration":      {"orchestration", "scheduling"},
	"monitoring":         {"monitoring"},
	"observability":      {"observability", "tracing", "logging"},
	"service-mesh":       {"service mesh", "service-proxy"},
	"networking":         {"networking", "network", "service discovery", "dns"},
	"container-runtime":  {"container runtime", "runtime"},
	"storage":            {"storage", "database"},
	"gitops":             {"continuous integration", "continuous delivery", "gitops"},
	"ci-cd":              {"ci/cd", "ci-cd", "continuous"},
	"security":           {"security", "key management", "policy"},
	"serverless":         {"serverless", "installable platform"},
	"messaging":          {"messaging", "streaming"},
	"build":              {"build", "image"},
	"registry":           {"registry", "container registry"},
	"package-management": {"package"},
	"automation":         {"automation", "configuration"},
	"chaos-engineering":  {"chaos"},
	"edge":               {"edge"},
	"ml-platform":        {"machine learning", "ai", "ml"},
}

func extractGitHubInfo(repoURL string) (owner, repo string) {
	if repoURL == "" || !strings.Contains(repoURL, "github.com") {
		return "", ""
	}

	parsed, err := url.Parse(repoURL)
	if err != nil {
		return "", ""
	}

	path := strings.Trim(parsed.Path, "/")
	path = strings.TrimSuffix(path, ".git")

	parts := strings.Split(path, "/")
	if len(parts) >= 2 {
		return parts[0], parts[1]
	}
	return "", ""
}

func getCategoryFromSubcategory(subcategoryName, categoryName string) string {
	nameLower := strings.ToLower(subcategoryName)
	if nameLower == "" {
		nameLower = strings.ToLower(categoryName)
	}

	for category, keywords := range categoryMapping {
		for _, keyword := range keywords {
			if strings.Contains(nameLower, keyword) {
				return category
			}
		}
	}
	return "other"
}

func downloadLandscape() ([]byte, error) {
	resp, err := http.Get(landscapeURL)
	if err != nil {
		return nil, fmt.Errorf("failed to download landscape: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("failed to download landscape: status %d", resp.StatusCode)
	}

	return io.ReadAll(resp.Body)
}

func main() {
	// Get output path from args or use default
	outputPath := "supply-chain/util/data/cncf-projects.yaml"
	if len(os.Args) > 1 {
		outputPath = os.Args[1]
	}

	fmt.Println("Downloading CNCF landscape.yml...")
	data, err := downloadLandscape()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	var landscape Landscape
	if err := yaml.Unmarshal(data, &landscape); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing landscape: %v\n", err)
		os.Exit(1)
	}

	projects := map[string][]ProjectEntry{
		"graduated":  {},
		"incubating": {},
		"sandbox":    {},
	}
	seenRepos := make(map[string]bool)

	for _, category := range landscape.Landscape {
		categoryName := category.Name
		for _, subcategory := range category.Subcategories {
			subcategoryName := subcategory.Name
			for _, item := range subcategory.Items {
				projectStatus := item.Project
				if projectStatus != "sandbox" && projectStatus != "incubating" && projectStatus != "graduated" {
					continue
				}

				owner, repo := extractGitHubInfo(item.RepoURL)
				if owner == "" || repo == "" {
					fmt.Fprintf(os.Stderr, "Warning: Skipping %s - no valid GitHub repo URL\n", item.Name)
					continue
				}

				repoKey := fmt.Sprintf("%s/%s", owner, repo)
				if seenRepos[repoKey] {
					continue
				}
				seenRepos[repoKey] = true

				mappedCategory := getCategoryFromSubcategory(subcategoryName, categoryName)

				entry := ProjectEntry{
					Owner:         owner,
					Repo:          repo,
					Name:          item.Name,
					Category:      mappedCategory,
					ProjectStatus: projectStatus,
				}

				// Extract accepted date if available
				if item.Extra != nil {
					if accepted, ok := item.Extra["accepted"].(string); ok {
						entry.AcceptedDate = accepted
					}
				}

				projects[projectStatus] = append(projects[projectStatus], entry)
			}
		}
	}

	// Sort projects by name within each status
	for status := range projects {
		sort.Slice(projects[status], func(i, j int) bool {
			return strings.ToLower(projects[status][i].Name) < strings.ToLower(projects[status][j].Name)
		})
	}

	// Build output structure
	output := Output{
		Metadata: Metadata{
			Source:        "https://github.com/cncf/landscape/blob/master/landscape.yml",
			Description:   "CNCF projects automatically synced from the CNCF landscape",
			AutoGenerated: true,
		},
		Repositories: []ProjectEntry{},
	}

	// Add repositories in order: graduated, incubating, sandbox
	for _, status := range []string{"graduated", "incubating", "sandbox"} {
		output.Repositories = append(output.Repositories, projects[status]...)
	}

	// Ensure output directory exists
	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output directory: %v\n", err)
		os.Exit(1)
	}

	// Write YAML output with disclaimer header
	outFile, err := os.Create(outputPath)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()

	// Write disclaimer header
	disclaimer := `# ============================================================================
# WARNING: THIS FILE IS AUTO-GENERATED - DO NOT EDIT MANUALLY!
# ============================================================================
#
# This file is automatically generated by the sync-cncf-projects workflow.
# Any manual changes will be overwritten on the next sync.
#
# Source: https://github.com/cncf/landscape/blob/master/landscape.yml
# Generator: supply-chain/util/extract-projects
# Workflow: .github/workflows/sync-cncf-projects.yml
#
# To update this file, either:
#   1. Wait for the scheduled daily sync (03:00 UTC)
#   2. Manually trigger the sync-cncf-projects workflow
#
# ============================================================================

`
	if _, err := outFile.WriteString(disclaimer); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing disclaimer: %v\n", err)
		os.Exit(1)
	}

	encoder := yaml.NewEncoder(outFile)
	encoder.SetIndent(2)
	if err := encoder.Encode(output); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing YAML: %v\n", err)
		os.Exit(1)
	}

	// Print statistics
	fmt.Printf("Extracted %d graduated projects\n", len(projects["graduated"]))
	fmt.Printf("Extracted %d incubating projects\n", len(projects["incubating"]))
	fmt.Printf("Extracted %d sandbox projects\n", len(projects["sandbox"]))
	fmt.Printf("Total: %d projects\n", len(output.Repositories))
	fmt.Printf("Output written to: %s\n", outputPath)
}
