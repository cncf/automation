package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v3"
)

type Repository struct {
	Owner         string `yaml:"owner" json:"owner"`
	Repo          string `yaml:"repo" json:"repo"`
	Name          string `yaml:"name" json:"name"`
	Category      string `yaml:"category" json:"category"`
	ProjectStatus string `yaml:"project_status" json:"project_status"`
	AcceptedDate  string `yaml:"accepted_date,omitempty" json:"accepted_date,omitempty"`
	DiscoveredBy  string `yaml:"discovered_by,omitempty" json:"discovered_by,omitempty"`
}

type Metadata struct {
	Source        string `yaml:"source"`
	Description   string `yaml:"description"`
	AutoGenerated bool   `yaml:"auto_generated"`
}

type CNCFProjects struct {
	Metadata     Metadata     `yaml:"metadata"`
	Repositories []Repository `yaml:"repositories"`
}

type DiscoveredRepos struct {
	Metadata     DiscoveredMetadata `yaml:"metadata"`
	Repositories []Repository       `yaml:"repositories"`
}

type DiscoveredMetadata struct {
	Description   string `yaml:"description"`
	AutoGenerated bool   `yaml:"auto_generated"`
	LastUpdated   string `yaml:"last_updated"`
}

type GitHubRepo struct {
	Name        string `json:"name"`
	FullName    string `json:"full_name"`
	Description string `json:"description"`
	Fork        bool   `json:"fork"`
	Archived    bool   `json:"archived"`
	Disabled    bool   `json:"disabled"`
	HasReleases bool   `json:"has_releases,omitempty"`
}

type GitHubRelease struct {
	TagName    string `json:"tag_name"`
	Draft      bool   `json:"draft"`
	Prerelease bool   `json:"prerelease"`
}

var httpClient = &http.Client{Timeout: 30 * time.Second}

func makeGitHubRequest(url string, token string) ([]byte, error) {
	maxRetries := 3
	for attempt := 0; attempt < maxRetries; attempt++ {
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Accept", "application/vnd.github.v3+json")
		req.Header.Set("User-Agent", "cncf-automation")
		if token != "" {
			req.Header.Set("Authorization", "token "+token)
		}

		resp, err := httpClient.Do(req)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()

		if resp.StatusCode == 404 {
			return nil, fmt.Errorf("not found")
		}

		// Handle rate limiting
		if resp.StatusCode == 403 || resp.StatusCode == 429 {
			if attempt < maxRetries-1 {
				retryAfter := 60 // Default wait time
				if ra := resp.Header.Get("Retry-After"); ra != "" {
					if parsed, err := time.ParseDuration(ra + "s"); err == nil {
						retryAfter = int(parsed.Seconds())
					}
				}
				fmt.Printf("    Rate limited, waiting %ds before retry...\n", retryAfter)
				time.Sleep(time.Duration(retryAfter) * time.Second)
				continue
			}
			return nil, fmt.Errorf("rate limited (HTTP %d)", resp.StatusCode)
		}

		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("HTTP %d", resp.StatusCode)
		}

		return io.ReadAll(resp.Body)
	}
	return nil, fmt.Errorf("max retries exceeded")
}

func getOrgRepos(org string, token string) ([]GitHubRepo, error) {
	var allRepos []GitHubRepo
	page := 1

	for {
		url := fmt.Sprintf("https://api.github.com/orgs/%s/repos?per_page=100&page=%d&type=public", org, page)
		data, err := makeGitHubRequest(url, token)
		if err != nil {
			// Try as user instead of org
			url = fmt.Sprintf("https://api.github.com/users/%s/repos?per_page=100&page=%d&type=public", org, page)
			data, err = makeGitHubRequest(url, token)
			if err != nil {
				return allRepos, err
			}
		}

		var repos []GitHubRepo
		if err := json.Unmarshal(data, &repos); err != nil {
			return allRepos, err
		}

		if len(repos) == 0 {
			break
		}

		allRepos = append(allRepos, repos...)
		page++

		// Safety limit
		if page > 20 {
			break
		}
	}

	return allRepos, nil
}

func hasReleases(owner, repo, token string) bool {
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/releases?per_page=1", owner, repo)
	data, err := makeGitHubRequest(url, token)
	if err != nil {
		return false
	}

	var releases []GitHubRelease
	if err := json.Unmarshal(data, &releases); err != nil {
		return false
	}

	// Check for at least one non-draft, non-prerelease
	for _, r := range releases {
		if !r.Draft && !r.Prerelease {
			return true
		}
	}

	// If we got any releases, consider it valid
	return len(releases) > 0
}

func hasGoMod(owner, repo, token string) bool {
	url := fmt.Sprintf("https://api.github.com/repos/%s/%s/contents/go.mod", owner, repo)
	_, err := makeGitHubRequest(url, token)
	return err == nil
}

func main() {
	// Get paths from args
	baseDir := "."
	if len(os.Args) > 1 {
		baseDir = os.Args[1]
	}

	token := os.Getenv("GITHUB_TOKEN")
	if token == "" {
		token = os.Getenv("GH_TOKEN")
	}
	if token == "" {
		fmt.Println("WARNING: No GITHUB_TOKEN or GH_TOKEN set. You will likely hit rate limits.")
		fmt.Println("Set a token with: $env:GITHUB_TOKEN = \"your-token\"")
		fmt.Println()
	}

	projectsFile := filepath.Join(baseDir, "supply-chain/util/data/cncf-projects.yaml")
	outputFile := filepath.Join(baseDir, "supply-chain/util/data/discovered-repos.yaml")

	// Read existing CNCF projects
	data, err := os.ReadFile(projectsFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading projects file: %v\n", err)
		os.Exit(1)
	}

	var projects CNCFProjects
	if err := yaml.Unmarshal(data, &projects); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing projects file: %v\n", err)
		os.Exit(1)
	}

	// Build set of known repos and collect unique orgs
	knownRepos := make(map[string]bool)
	orgs := make(map[string]Repository) // org -> example repo for category/status

	for _, repo := range projects.Repositories {
		key := fmt.Sprintf("%s/%s", strings.ToLower(repo.Owner), strings.ToLower(repo.Repo))
		knownRepos[key] = true
		orgs[strings.ToLower(repo.Owner)] = repo
	}

	fmt.Printf("Found %d known repositories from %d organizations\n", len(knownRepos), len(orgs))

	// Read existing discovered repos to avoid re-scanning
	existingDiscovered := make(map[string]bool)
	if existingData, err := os.ReadFile(outputFile); err == nil {
		var existing DiscoveredRepos
		if yaml.Unmarshal(existingData, &existing) == nil {
			for _, repo := range existing.Repositories {
				key := fmt.Sprintf("%s/%s", strings.ToLower(repo.Owner), strings.ToLower(repo.Repo))
				existingDiscovered[key] = true
			}
		}
	}

	// Scan each org for additional repos
	var discovered []Repository
	scannedOrgs := 0
	totalOrgRepos := 0

	for org, exampleRepo := range orgs {
		scannedOrgs++
		fmt.Printf("[%d/%d] Scanning %s...\n", scannedOrgs, len(orgs), org)

		repos, err := getOrgRepos(org, token)
		if err != nil {
			fmt.Printf("  Warning: Could not fetch repos for %s: %v\n", org, err)
			continue
		}

		totalOrgRepos += len(repos)
		newInOrg := 0

		for _, repo := range repos {
			// Skip forks, archived, disabled repos
			if repo.Fork || repo.Archived || repo.Disabled {
				continue
			}

			key := fmt.Sprintf("%s/%s", strings.ToLower(org), strings.ToLower(repo.Name))

			// Skip if already known
			if knownRepos[key] {
				continue
			}

			// Skip if already discovered before
			if existingDiscovered[key] {
				continue
			}

			// Check if it has releases
			if !hasReleases(org, repo.Name, token) {
				continue
			}

			// Check if it's a Go project
			if !hasGoMod(org, repo.Name, token) {
				continue
			}

			newInOrg++
			discovered = append(discovered, Repository{
				Owner:         org,
				Repo:          repo.Name,
				Name:          repo.Name,
				Category:      exampleRepo.Category,
				ProjectStatus: exampleRepo.ProjectStatus,
				DiscoveredBy:  fmt.Sprintf("org-scan from %s/%s", exampleRepo.Owner, exampleRepo.Repo),
			})

			fmt.Printf("  + Found: %s/%s\n", org, repo.Name)
		}

		if newInOrg > 0 {
			fmt.Printf("  Discovered %d new repos in %s\n", newInOrg, org)
		}

		// Rate limit protection - wait 1 second between orgs
		time.Sleep(1 * time.Second)
	}

	// Sort discovered repos
	sort.Slice(discovered, func(i, j int) bool {
		if discovered[i].Owner != discovered[j].Owner {
			return discovered[i].Owner < discovered[j].Owner
		}
		return discovered[i].Repo < discovered[j].Repo
	})

	// Merge with existing discovered repos
	if existingData, err := os.ReadFile(outputFile); err == nil {
		var existing DiscoveredRepos
		if yaml.Unmarshal(existingData, &existing) == nil {
			discovered = append(existing.Repositories, discovered...)
		}
	}

	// Remove duplicates
	seen := make(map[string]bool)
	var uniqueDiscovered []Repository
	for _, repo := range discovered {
		key := fmt.Sprintf("%s/%s", strings.ToLower(repo.Owner), strings.ToLower(repo.Repo))
		if !seen[key] {
			seen[key] = true
			uniqueDiscovered = append(uniqueDiscovered, repo)
		}
	}
	discovered = uniqueDiscovered

	// Sort again after merge
	sort.Slice(discovered, func(i, j int) bool {
		if discovered[i].Owner != discovered[j].Owner {
			return discovered[i].Owner < discovered[j].Owner
		}
		return discovered[i].Repo < discovered[j].Repo
	})

	// Write output
	output := DiscoveredRepos{
		Metadata: DiscoveredMetadata{
			Description:   "Additional repositories discovered in CNCF project organizations. These repos have releases and contain go.mod.",
			AutoGenerated: true,
			LastUpdated:   time.Now().UTC().Format(time.RFC3339),
		},
		Repositories: discovered,
	}

	// Write with disclaimer header
	outFile, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()

	disclaimer := `# ============================================================================
# WARNING: THIS FILE IS AUTO-GENERATED - DO NOT EDIT MANUALLY!
# ============================================================================
#
# This file contains additional repositories discovered in CNCF project
# organizations that are not listed in the main cncf-projects.yaml.
#
# These repositories:
# - Belong to the same GitHub org/user as a CNCF project
# - Have at least one release
# - Contain a go.mod file (Go-based project)
#
# Generator: supply-chain/util/discover-repos
# Workflow: .github/workflows/discover-cncf-repos.yml
#
# ============================================================================

`
	if _, err := outFile.WriteString(disclaimer); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing disclaimer: %v\n", err)
		os.Exit(1)
	}

	encoder := yaml.NewEncoder(outFile)
	encoder.SetIndent(2)
	if err := encoder.Encode(output); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing YAML: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\n=== Summary ===\n")
	fmt.Printf("Scanned %d organizations\n", scannedOrgs)
	fmt.Printf("Total repos in orgs: %d\n", totalOrgRepos)
	fmt.Printf("Total discovered repos: %d\n", len(discovered))
	fmt.Printf("Output written to: %s\n", outputFile)
}
